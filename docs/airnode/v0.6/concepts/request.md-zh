---
title: 请求
---

<TitleSpan>概念和定义</TitleSpan>

# {{$frontmatter.title}}

<VersionWarning/>

<TocHeader /> <TOC class="table-of-contents" :include-level="[2,3,4]" />

由 [请求者](requester.md)提出了请求， 传递到[AirnodeRrp. ol](README.md#airnoderrp-sol) 协议合约的`makeFullRequest()` 或 `makeTemplateRequest()` 函数 ，将请求添加到它的存储。 目标链外 [Airnode](airnode.md) 从AirnodeRrp.sol的存储中收集请求，并使用AirnodeRrp.sol的`fulFill()`函数进行响应。

> ![concepts-request](../assets/images/concepts-request.png)
> 
> 1. <p class="diagram-line">请求者在 AirnodeRrp 协议合约上调用 makeFullRequest() 函数 。</p>
> 2. <p class="diagram-line">makeFullRequest() 为请求分配了一个requestId用于跟踪，将requestId添加到存储，将请求发送到事件日志，并将requestId返回给请求者。</p>
> 3. <p class="diagram-line" style="color:gray;">Airnode在其运行周期中，从事件日志中挑选请求。</p>
> 4. <p class="diagram-line" style="color:blue;">Airnode从API获得数据并进行编码。 编码响应的长度不能超过 1024 字节。 (这在实践中可以忽略不计，因为大型响应的存储成本很高）。</p>
> 5. <p class="diagram-line" style="color:green;">Airnode将响应发送给AirnodeRrp中的fulFill()，后者反过来从存储中移除待定的requestId并将响应转发给myFulFill()。 RequestId被作为响应的一部分。</p>

了解更多关于如何 [调用 Airnode](../grp-developers/call-an-airnode. md)。

## `requestId`

`requestId` 唯一标识了一个请求。 当请求者使用AirnodeRrp.sol发出请求时，在请求被添加到事件日志之前，会生成一个`requestId`，并将requestId返回给请求者。 这个 `requestId`是某些数据成员的哈希值，取决于哪种类型的请求，如`makeFullRequest()` 或`makeTemplateRequest()`。 它们的不同之处在于，一个使用 `endpointId` 加上`airnode`地址，另一个使用`templateId` （因为模板已经包含 `airnode`地址）。

| makeFullRequest()                                              | makeTemplateRequest()                                          |
|:-------------------------------------------------------------- |:-------------------------------------------------------------- |
| block.chainid                                                  | block.chainid                                                  |
| address(this)                                                  | address(this)                                                  |
| msg.sender                                                     | msg.sender                                                     |
| requesterRequestCount                                          | requesterRequestCount                                          |
|                                                                | airnode                                                        |
| <span style="color:purple;font-weight:bold;">endpointId</span> | <span style="color:purple;font-weight:bold;">templateId</span> |
| sponsor                                                        | sponsor                                                        |
| sponsorWallet                                                  | sponsorWallet                                                  |
| fulfillAddress                                                 | fulfillAddress                                                 |
| fulfillFunctionId                                              | fulfillFunctionId                                              |
| parameters                                                     | parameters                                                     |

After the request (with `requestId`) is added to the event logs, Airnode gathers the request and verifies the `requestId` by re-computing its hash before responding to the request. 这是用来验证参数没有被篡改。

## 请求参数

下面的列表概括了请求的参数的预期值。

- `templateId`是要使用的模板的ID_(仅用于 `makeTemplateRequest`)_。

- `airnode` (address)（地址）和 `endpointId` 用于指定端点 _(仅用于 `makeFullRequest`)_。

- `sponsor` 和`sponsorWallet` （地址）用于指定哪个钱包将被用来完成请求。

- `fulfillAddress`和`fulfillFunctionId` 用于指定哪个合约/函数将被调用，以完成请求。

- `parameters` specify the API and [reserved](/ois/v1.0.0/ois.md#_5-4-reservedparameters) parameters (see [Airnode ABI specifications](../reference/specifications/airnode-abi-specifications.md) for how these are encoded)

## Full Request

A full request does not refer to a template at all. Full requests are useful if the requester will not make a similar request ever again (e.g., in a prediction market context).

```solidity
function makeFullRequest(
    address airnode,
    bytes32 endpointId,
    address sponsor,
    address sponsorWallet,
    address fulfillAddress,
    bytes4 fulfillFunctionId,
    bytes calldata parameters
){...}
```

## Template Request

A template request refers to a template for the `airnode` address, `endpointId` and `parameters`.

```solidity
struct Template {
  address airnode;
  bytes32 endpointId;
  bytes parameters;
}
```

The requester can refer to the `templateId` of a template while making a request, and the Airnode will fetch these and use them in the request.

```solidity
function makeTemplateRequest(
    bytes32 templateId,
    address sponsor,
    address sponsorWallet,
    address fulfillAddress,
    bytes4 fulfillFunctionId,
    bytes calldata parameters
)
```

When a template is used to make a request, both the parameters encoded in `parameters` of the template and `parameters` provided at request-time by the requester will be used by the Airnode. In case the two include a parameter with the same name, the one provided at request-time will be used.

## Request Outcomes

A request made to an Airnode has three possible outcomes:

- [Fulfill](./request.md#fulfill)
- [Fail](./request.md#fail)
- [Ignore](./request.md#ignore)

### Fulfill

`fulfill()` is the desired outcome and it will only be called if Airnode received a successful response from the API provider.

> ![request-outcomes](../assets/images/request-outcomes.png)
> 
> 1. <p class="diagram-line">Airnode calls AirnodeRRP.fulFill() with a response only if the API has not responded with an error. AirnodeRrp.fulfill() performs a call back to myFulFill() which in turn receives the response.</p>
> 2. <p class="diagram-line" style="color:green;">If AirnodeRrp.fulFill() fails internally or the underlying low level call to myFulFill() reverts then Airnode will start the process in step #3 to fail the request.</p>
> 3. <p class="diagram-line" style="color:green;">If Airnode errors, or is told by AirnodeRrp.fulFill() to error, it calls AirnodeRrp.fail() which removes the request from the pending list of requestIds on-chain.</p>

::: tip Important to Note

Fulfill is the only outcome that returns results to a requester contract.

:::

For a successful request, Airnode calls the `fulfill()` function in AirnodeRrp.sol that will in turn call back the requester contract at `fulfillAddress` using function `fulfillFunctionId` to deliver `data`.

`fulfill()` also receives a signature to validate on-chain that the response data was submitted by the Airnode. This is to prevent requesters from fulfilling their own requests in order to manipulate data submitted by AirnodeRrp.sol.

`fulfill()` will not revert if the `fulfillFunctionId` external call reverts. However, it will return `false` in this case or if there is no function with a matching signature at `fulfillAddress`. On the other hand, it will return `true` if the external call returns successfully or if there is no contract deployed at `fulfillAddress`. In the case `false` is returned then an error message will also be returned in a variable which can be decoded to retrieve the revert string. For example Airnode will decode this variable when this function returns `false` and call `fail()` on AirnodeRrp.sol with the revert string as the error message.

### Fail

As noted in the diagram above, if the transaction that calls `fulfill()` returns `false`, the Airnode decodes the revert string and calls the `fail()` method to report the failure. For privacy and security reasons, API error messages are not sent on-chain. Also note that the node will not attempt to fulfill a failed request afterwards.

Airnode is stateless, which means that there is no database storing which requests have been fulfilled or failed, which are waiting on confirmations and which are still pending. This information is retrieved from the chain on each request-response cycle (roughly every minute). During each cycle, retrieved requests need to be ordered in the same way to ensure they are submitted using the same nonce. This is important because it's possible for a transaction to not have been confirmed by the time the next cycle runs. If this happens, the transaction is re-submitted with a "faster" transaction fee, overwriting the previous transaction.

### Blocked

Airnode is also dependent on the blockchain provider to supply it with the onchain data. If the blockchain provider is unavailable for whatever reason, it is possible that a request cannot be fully validated, which means that it cannot be submitted back to the blockchain. As mentioned above, keeping requests in the same order, using the same nonce is critical. Therefore, any request that cannot be fully validated due to a blockchain provider error becomes "blocked". This means that it and any requests after it are unable to be submitted during the current cycle and will be retried during the following cycle. It is important to note that this is specific to each requester. e.g. a request sent from requester A that becomes "blocked", will not block requests sent from requester B.

The blocked requests get ignored after `ignoreBlockedRequestsAfterBlocks` (default value: 20), meaning that they are treated as an Ignored request (invalid requests are ignored, e.g., a request whose sponsor and sponsorWallet don't match).

#### Blocking cases

In chronological order in the coordinator life-cycle.

1. Airnode RRP has full requests (`makeFullRequest()1`), for which all parameters are specified, or template requests, which specify some of the parameters and specify the ID of a template that contains the rest of the parameters. After fetching templates, if the node can't find the template for a template request, that request gets blocked. This may happen if the blockchain provider is not responding to valid requests (e.g., the node is making too many requests and is being rate-limited).

2. To check authorization for a request, the node needs to know its endpoint ID. Full requests already specify the endpoint ID, and the templates should be fetched for template requests by this point, which specify the endpoint ID. While checking authorizations, if the endpoint ID of a request is not specified, that request gets blocked. This should never happen, because template requests that are missing templates are already blocked in sample #1 above.

3. The node makes a static call with some of the request parameters to check if a specific request is authorized (i.e., if it should respond to it). After fetching authorization results, if the node can't find the results for a request, that request gets blocked.This may happen if the blockchain provider is not responding to valid requests (e.g., the node is making too many requests and is being rate-limited).

4. The node invokes a worker for each request with a unique request ID to make the API calls. These workers should return either with a payload or an error (if the call has timed our or the API errored). While mapping the worker responses back (referred to as “disaggregation” in the code), if the node can't find the response for a request, that request gets blocked. In theory this should never happen.

### Ignore

If the Airnode cannot even fail a request (e.g., the requester is not sponsored by the sponsor), the request gets ignored.

After X blocks (20 by default for EVM chains), any requests that would become "blocked", will instead become "ignored". This means that Airnode will stop attempting to process the request in order to process later requests.

## Check if request is awaiting fulfillment

There is a convenience method in AirnodeRrp.sol called `requestIsAwaitingFulfillment()` that can be called to check if a request was made but not yet fulfilled/failed. If a requester has made a request, received a `requestId` but did not hear back, it can call this method to check if the Airnode has called back `fail()` instead.Returns `true` if the request is awaiting fulfillment (i.e., `true` if `fulfill()` or `fail()` is not called back yet), `false` otherwise.
