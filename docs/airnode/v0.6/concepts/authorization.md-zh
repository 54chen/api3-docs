---
title: 授权者
---

<TitleSpan>概念和定义</TitleSpan>

# {{$frontmatter.title}}

<VersionWarning/>

<TocHeader /> <TOC class="table-of-contents" :include-level="[2,5]" />

Airnode可以使用授权者，授权请求者对其底层API的合约访问。 作为一种选项，API供应商也可以使用[中继元数据](./relay-meta-auth.md) 来验证请求。 授权者需要API供应商具备区块链相关知识，中继元数据则不需要。

与授权者和中继元数据相关的其他文档：

- [使用授权者](../grp-providers/guides/build-an-airnode/apply-auth.md)
- [API 安全性](../grp-providers/guides/build-an-airnode/api-security.md)

当Airnode收到一个请求时，它可以使用链上的授权者合约来验证是否有必要作出回应。 授权者允许Airnode采取各种各样的措施。 以下是一些示例：

- 响应已经用DAI支付每月订阅费的赞助者的请求。
- 响应已用API3代币支付每次调用费用的个别请求。
- 响应被API3 DAO列入白名单的请求者提出的请求。
- 响应由Airnode所有者的后台（例如基于PayPal付款）列入白名单的赞助者提出的请求。

授权者的一个常见用例是为Airnode运营商开发的[RequesterAuthorizerWithAirnode](#requesterauthorizerwithairnode)授权者合约，这是可直接使用的。 它允许在每个端点的基础上，对请求者合约（有或没有过期时间戳）设置白名单。 这是最常用的情况，实际上已经可以满足许多Airnodes的需要。

下图说明Airnode 如何使用授权者。

> ![concept-authorizer](../assets/images/concepts-authorizers.png)
> 
> 1. <p class="diagram-line">当Airnode启动时，它会读取其在config.json中声明的授权者合约列表。</p>
> 2. <p class="diagram-line">Airnode在其运行周期内从事件日志中收集请求。</p>
> 3. <p class="diagram-line">Airnode 将每个请求与授权者合约列表一起，发送到 <code>checkAuthorizationStatus()</code>。</p>
> 4. <p class="diagram-line"><code>checkauthorizationStatus()</code> 执行每个授权者合约中的<code>isAuthorized()</code>函数。 如果任何一个授权者合同返回 "true"，那么 "true "就会返回给Airnode，Airnode进而着手继续执行请求。</p>

### Airnode 授权策略

Airnode提供了两个授权者合同，其中一个（RequesterAuthorizerWithAirnode）可以被任何API供应商使用。 另一个（RequesterAuthorizerWithManager）则是由API3 DAO使用的。 本文档中的以下章节将会对它进行详细介绍。

- [`RequesterAuthorizerWithAirnode`](#requesterauthorizerwithairnode)
- [`RequesterAuthorizerWithManager`](#requesterauthorizerwithmanager)

这两个授权者合约都继承和扩展了`RequesterAuthorizer`抽象合约，该合约也扩展了 `Whitelist`合约。 这意味着这两个授权者合约在向Airnode提供请求者合约之前，都需要对其设置白名单（对于`RequesterAuthorizerWithAirnode` ，可以使用[admin-cli](../reference/packages/admin-cli.md#requesterauthorizerwithairnode)完成）。

它们之间的主要区别是： `RequterAuthorizerWiAirnode` 允许 Airnode 为指定的 Airnode授予白名单角色。 On the other hand, `RequesterAuthorizerWithManager` allows the manager address (read: the API3 DAO) to grant whitelisting roles for all Airnodes that use it.

Some common functions available are:

- `requesterIsWhitelisted`: Called to check if a requester is whitelisted to use the Airnode–endpoint pair.
- <code style="  overflow-wrap: break-word;">airnodeToEndpointIdToRequesterToWhitelistStatus</code>: Called to get the detailed whitelist status of a requester for the Airnode–endpoint pair.

### Custom Authorizers

Custom authorizer contracts can implement any arbitrary authorization logic. An example might be where Airnode only responds to requests if the requester has made less than a specific number of requests to the Airnode in the last month, effectively implementing an on-chain call quota.

### Authorizer List

Airnode authorizers are listed in the config.json file at [`chains[n].authorizers`](../grp-providers/guides/build-an-airnode/configuring-airnode.md#chains). An authorizer typically checks for a single condition (has the requester made their monthly payment, is the `requester` whitelisted, etc.). Authorizers can be combined to enforce more complex policies. If any of the authorizers in the list gives access, the request will considered to be authorized. From a logical standpoint, the authorization outcomes get `OR`ed.

### Authorizer Interface

Authorizer contracts that inherit from `IAuthorizer` can be used to implement an arbitrary authorization policy based on its input parameters.

- `requestId`: bytes32
- `airnode`: address
- `endpointId`: bytes32
- `sponsor`: address
- `requester`: address

Note that the authorizer does not have to use all of the arguments, and can even decide on arbitrary on-chain criteria such as `block.number` (e.g., do not respond to anyone after block number N). An authorizer is a contract with the following interface:

```solidity
interface IAuthorizer {
    function isAuthorized(
        bytes32 requestId,
        address airnode,
        bytes32 endpointId,
        address sponsor,
        address requester
    ) external view returns (bool);
}
```

Below is an example of how to create the simplest form of an authorizer. This authorizer allows any requester contract to call the endpointId (0xf2ee...).

```solidity
contract myAuthorizer is IAuthorizer
{
  function isAuthorized(
      bytes32 requestId,
      address airnode,
      bytes32 endpointId,
      address sponsor,
      address requester
  ) external view override returns (bool) {
      bytes32 expected = 0xf2ee...;
      return endpointId == expected;
  }
}
```

### Why is an authorization scheme needed?

Airnodes need the ability to fulfill requests selectively. This is required for two main reasons:

1. The Airnode only fulfills requests made by requesters who have made payment to the Airnode owner, which allows them to monetize their services.
2. The services of the Airnode are sensitive and can only be accessed by certain requesters, e.g., who have gone through KYC.

A protocol that does not have the authorizer scheme or equivalent functionality cannot be considered as permissionless, and will not be able to achieve wide-spread adoption.

### Are authorizers required?

Authorizers are not required. An Airnode operator could use [Relayed Meta Data Security Schemes](../grp-providers/guides/build-an-airnode/api-security.md#relayed-meta-data-security-schemes). It is possible to use both authorizers and relay security schemes together.

### How are authorizers implemented?

There are two main points to consider about how authorization policies are implemented:

1. If the policies are kept off-chain, the requester cannot see them or check if they satisfy them. Furthermore, the Airnode owner updating the policies (e.g., increasing the service fees) requires off-chain coordination with the requester.
2. Embedding the policies in the request–response loop results in a gas cost overhead.

Based on these considerations, Airnode uses a hybrid method. An Airnode announces its authorization policy through off-chain channels as the addresses of a list of authorizer contracts. Whenever the Airnode receives a request, it checks if it should fulfill this request by making a static call that queries this on-chain policy. Similarly, the requester can use this on-chain policy by making a static call to check if they are authorized. This scheme both allows the Airnode to set transparent and flexible policies, and this to be done with no gas overhead.

### Access (deny, allow, filter)

How authorizers impact access is based on the `chains` field of `config.json` for a given Airnode.

#### Deny All

If the Airnode wants to deny all access for a particular chain, it should not operate on it (i.e., it should not exist in the `chains` list). The below example would "deny all" to chains 1 and 3–n since they do not have entries in the `chains` field.

```json
 chains:[
   {
    id:2,
    authorizers:[],
    ...
   }
 ]
```

#### Allow All

A `chains.authorizers` list of [] means "let everyone through". In the example below chain 2 would allow access to any requester.

```json
  chains:[
    {
      id:2,
      authorizers:[]
      ...
    },
    ...
 ]
```

#### Filter All

If the Airnode wants to give access selectively, it should use one or more authorizers that implement filtering logic. In the example below the Airnode will accept requests on chain _"2"_ and the requester would be filtered by two authorizers.

```json
 chains:[
   id:2,
   authorizers:['0xcd...cd8d','0xff...d19c]
   ...
 ]
```

### RequesterAuthorizerWithAirnode

This contract implements a requester-based RRP authorizer with three types of roles

1. Whitelist expiration extender: Is allowed to extend temporary whitelisting expiration
2. Whitelist expiration setter: Is allowed to set the temporary whitelisting expiration (i.e., they can also reduce the expiration time)
3. Indefinite whitelister: Is allowed to whitelist/unwhitelist indefinitely Each Airnode's address is treated as if they have all these three roles for the respective Airnode, and they can also grant these roles to other accounts, which includes contracts that implement arbitrary business logic.

#### extendWhitelistExpiration

The `extendWhitelistExpiration()` function can be called by a whitelist expiration extender or the Airnode address to extend the whitelist expiration of a requester for the Airnode–endpoint pair.

This function emits a `ExtendedWhitelistExpiration` event with the following signature:

```
    event ExtendedWhitelistExpiration(
        address indexed airnode,
        bytes32 endpointId,
        address indexed requester,
        address indexed sender,
        uint256 expiration
    );
```

#### setWhitelistExpiration

The `setWhitelistExpiration()` function can be called by a whitelist expiration setter or the Airnode address to set the whitelisting expiration of a requester for the Airnode–endpoint pair. This can hasten expiration.

This function emits a `SetWhitelistExpiration` event with the following signature:

```
    event SetWhitelistExpiration(
        address indexed airnode,
        bytes32 endpointId,
        address indexed requester,
        address indexed sender,
        uint256 expiration
    );
```

#### setWhitelistStatusPastExpiration

The `setWhitelistStatusPastExpiration()` function can be called by an indefinite whitelister or the Airnode address to set the whitelist status of a requester past expiration for the Airnode–endpoint pair. This is useful to allow access to an API even if the expiration date has passed. For example, keep authorizing requests while a sum of API3 tokens is locked.

This function emits a `ExtendedWhitelistExpiration` event with the following signature:

```
    event SetWhitelistStatusPastExpiration(
        address indexed airnode,
        bytes32 endpointId,
        address indexed requester,
        address indexed sender,
        bool status
    );
```

#### isAuthorized

The `isAuthorized()` function will be called by AirnodeRrp to verify the authorization status of a request. This function will return true for all whitelisted requester contracts, admins and Airnode operator address.

### RequesterAuthorizerWithManager

This contract implements a requester-based RRP authorizer and assigns the API3 DAO as the manager or in other words, the highest ranking admin across all Airnodes.

The manager and the accounts that it has granted the whitelist expiration extender, whitelist expiration setter and the indefinite whitelister roles will use `RequesterAuthorizerWithManager` to whitelist requesters across all Airnodes.

#### extendWhitelistExpiration

The `extendWhitelistExpiration()` function can be called by a whitelist expiration extender or the manager to extend the whitelist expiration of a requester for the Airnode–endpoint pair.

This function emits a `ExtendedWhitelistExpiration` event with the following signature:

```
    event ExtendedWhitelistExpiration(
        address indexed airnode,
        bytes32 endpointId,
        address indexed requester,
        address indexed sender,
        uint256 expiration
    );
```

#### setWhitelistExpiration

The `setWhitelistExpiration()` function can be called by a whitelist expiration setter or the manager to set the whitelisting expiration of a requester for the Airnode–endpoint pair. This can hasten expiration.

This function emits a `SetWhitelistExpiration` event with the following signature:

```
    event SetWhitelistExpiration(
        address indexed airnode,
        bytes32 endpointId,
        address indexed requester,
        address indexed sender,
        uint256 expiration
    );
```

#### setWhitelistStatusPastExpiration

The `setWhitelistStatusPastExpiration()` function can be called by an indefinite whitelister or the manager to set the whitelist status of a requester past expiration for the Airnode–endpoint pair. This is useful to allow access to an API even if the expiration date has passed. For example, keep authorizing requests while a sum of API3 tokens is locked.

This function emits a `ExtendedWhitelistExpiration` event with the following signature:

```
    event SetWhitelistStatusPastExpiration(
        address indexed airnode,
        bytes32 endpointId,
        address indexed requester,
        address indexed sender,
        bool status
    );
```

#### isAuthorized

The `isAuthorized()` function will be called by AirnodeRrp to verify the authorization status of a request. This function will return true for all whitelisted requester contracts, admins and the meta-admin address.

<divider/>
